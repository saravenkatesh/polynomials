from decimal import DivisionByZero
from fractions import Fraction

from polynomials.polynomial import Polynomial
import polynomials.poly_methods as methods 

def mono_coefficients(Mono_1, Mono_2):
    """Returns the monomial coefficients used in the Buchberger algorithm.
    
    Arguments:
    Mono_1, Mono_2 -- instances of Polynomial with one term each.
    
    Returns:
    A tuple of monomials.  In the notation of the Buchberger algorithm, 
    (a_ij / g_i, a_ij / g_j)."""

    if Mono_1.is_zero or Mono_2.is_zero:
        raise DivisionByZero("Can't perform this Buchberger implementation on the zero polynomial.")

    #List of the largest exponents per variable appearing in either Mono_1 or Mono_2.
    lcm = [ max(term) for term in zip(Mono_1.leading_monomial, Mono_2.leading_monomial) ]

    #Lists describing the exponents of the monomial formed by dividing 
    #lcm(Mono_1, Mono_2) by Mono_1, respectively Mono_2
    coeff_term_1 = [lcm_term - mono_1 for lcm_term, mono_1 in zip(lcm, Mono_1.leading_monomial) ]
    coeff_term_2 = [lcm_term - mono_2 for lcm_term, mono_2 in zip(lcm, Mono_2.leading_monomial) ]

    return Polynomial({tuple(coeff_term_1): Fraction(1, Mono_1.leading_coeff)}), \
        Polynomial({tuple(coeff_term_2): Fraction(1, Mono_2.leading_coeff)})

#TODO implement exception handling for sets that include the zero polynomial.
def buchberger(poly_set):
    """Returns a Gröbner basis for the ideal generated by poly_set.
    
    Arguments:
    poly_set -- a list of non-zero Polynomial instances.
    
    Returns:
    G -- a sorted list of Polynomial instances that form a Gröbner basis."""

    G = poly_set[:]

    poly_pairs = [(poly_set[i], poly_set[j]) for i in range(len(poly_set)) \
        for j in range(i+1, len(poly_set))]
    
    while poly_pairs:
        poly_f_i, poly_f_j = poly_pairs[-1]
        Coeff_i, Coeff_j = mono_coefficients(poly_f_i.leading_term, poly_f_j.leading_term)
        
        #Define the S polynomial
        Poly_S_i = methods.poly_mul(Coeff_i, poly_f_i) 
        Poly_S_j = methods.poly_mul(Coeff_j, poly_f_j)
        Poly_S = methods.poly_subtract(Poly_S_i, Poly_S_j)
        poly_pairs.pop()

        #Add Poly_S to G if the reduction of Poly_S modulo G is non-zero.
        if not methods.reduction(Poly_S, G).is_zero:
            poly_pairs += [(poly, Poly_S) for poly in G]
            G.append(Poly_S)

    return G
